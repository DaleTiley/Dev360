@model MillenniumWebFixed.ViewModels.CloneQuoteVm
@{ Layout = null; }

<div class="modal-header">
    <h5 class="modal-title">Clone Quote</h5>
    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
</div>

@using (Html.BeginForm("Clone", "ProjectQuotes", FormMethod.Post, new { id = "cloneQuoteForm" }))
{
    @Html.AntiForgeryToken()
    @Html.HiddenFor(m => m.SourceQuoteId)

    <div class="modal-body">
        <div class="row g-3">
            <div class="col-md-6">
                @Html.LabelFor(m => m.BuildingType, new { @class = "form-label small", @for = "Clone_BuildingType" })
                @Html.TextBoxFor(m => m.BuildingType, new
                {
                    id = "Clone_BuildingType",               // <— unique ID in modal
                    @class = "form-control form-control-sm text-uppercase",
                    autocomplete = "off"
                })
                @Html.ValidationMessageFor(m => m.BuildingType, "", new { @class = "text-danger small" })
            </div>

            <div class="col-md-6">
                @Html.LabelFor(m => m.QuotationOption, new { @class = "form-label small", @for = "Clone_QuotationOption" })
                @Html.TextBoxFor(m => m.QuotationOption, new
                {
                    id = "Clone_QuotationOption",            // <— unique ID in modal
                    @class = "form-control form-control-sm",
                    type = "number",
                    min = "1",
                    step = "1",
                    inputmode = "numeric",
                    autocomplete = "off"
                })
                @Html.ValidationMessageFor(m => m.QuotationOption, "", new { @class = "text-danger small" })
            </div>
        </div>

        <div class="mt-3 alert alert-info small mb-0">
            <strong>What happens when you clone:</strong>
            <ul class="mb-0 ps-3">
                <li>A <em>new</em> quote will be created for this project; the original stays unchanged.</li>
                <li><strong>Quote No</strong> will advance to the next available number.</li>
                <li><strong>Revision</strong> will reset to <strong>A</strong>.</li>
                <li>You can change <strong>Building Type</strong> and/or <strong>Quotation Option</strong> before cloning.</li>
                <li>All other fields will be copied into the new quote. The clone will start with status <strong>Draft</strong>.</li>
            </ul>
        </div>
    </div>

    <div class="modal-footer">
        <button type="button" class="btn btn-light btn-sm" data-bs-dismiss="modal">Cancel</button>
        <button type="submit" class="btn theme-button btn-sm">
            <i class="fa fa-copy me-1"></i> Clone
        </button>
    </div>
}

<script>
    (function () {
        const form = document.getElementById('cloneQuoteForm');
        if (!form) return;

        // Elements (query inside THIS form so we never hit same-named fields outside)
        const bt = form.querySelector('input[name="BuildingType"]');
        const qo = form.querySelector('input[name="QuotationOption"]');

        // Helper: make sure the element is fully editable
        function unlock(el) {
            if (!el) return;
            el.readOnly = false;
            el.disabled = false;
            el.removeAttribute('readonly');
            el.removeAttribute('disabled');
            el.classList.remove('disabled');
        }

        // Helper: stop global key handlers from swallowing keystrokes
        function shieldKeys(el) {
            if (!el) return;
            const stop = e => { e.stopPropagation(); /* and prevent default only if something else blocked it */ };
            el.addEventListener('keydown', stop, true);
            el.addEventListener('keypress', stop, true);
            el.addEventListener('keyup', stop, true);
        }

        // Auto-uppercase BT locally
        if (bt) bt.addEventListener('input', () => { bt.value = (bt.value || '').toUpperCase(); });

        // When the modal becomes visible, (re)unlock & shield the inputs, then focus BT
        const modal = form.closest('.modal');
        if (modal) {
            modal.addEventListener('shown.bs.modal', function () {
                unlock(bt); unlock(qo);
                shieldKeys(bt); shieldKeys(qo);
                setTimeout(() => bt?.focus(), 0);
            });
        } else {
            // If the partial was injected into an already-open modal
            unlock(bt); unlock(qo); shieldKeys(bt); shieldKeys(qo);
            setTimeout(() => bt?.focus(), 0);
        }

        // AJAX submit (same as before)
        form.addEventListener('submit', function (e) {
            e.preventDefault();
            const fd = new FormData(form);
            fetch(form.action, { method: 'POST', headers: { 'X-Requested-With': 'XMLHttpRequest' }, body: fd })
                .then(r => r.json().catch(() => null).then(j => j || r.text()))
                .then(res => {
                    if (res && res.ok && res.redirect) {
                        window.location.href = res.redirect;
                    } else if (typeof res === 'string') {
                        const modalContent = form.closest('.modal-content');
                        if (modalContent) modalContent.innerHTML = res;     // server re-render with validation errors
                    } else {
                        form.submit(); // fallback
                    }
                })
                .catch(() => form.submit());
        });
    })();
</script>

